---
title: 网络基础
date: 2019-07-14 09:19:04
tags: 网络
---

##### 网络发展背景

- 网络分类

  - 局域网
  - 城域网
  - 广域网
  - 因特网/互联网
  - 以太网
  - 令牌环网

- IP地址

  - 功能：在网络中唯一表示一台主机
    - IPV4uint32_4--无符号32位整数---IP地址数量不到43亿
    - DHCP
    - NAT
  - IPV6：uint8_ip[16]---因为步向前兼容IPv4，因此没有很好的推广起来
  - 在网络中每条数据中都会包含两条信息：源段IP地址，目的端IP地址

- port端口

  - 功能：在一台主机上标识一个进程
    - uint16_t无符号16位整数
    - 范围：0~65535
  - 特性：一个端口只能被一个进程占用，但是一个进程可以使用多个端口，在网络中每条数据中都会包含两条信息：源端口，目的端口

- 协议：约定->通信协议：通信双方的数据格式约定（实现互联）

  - 协议分层：按照每层提供的服务，使用的协议，提供的接口，对复杂的网路环境进行分层

    - OSI七层参考模型（不实用）
      1. 应用层
      2. 表示层
      3. 会话层
      4. 传输层
      5. 网络层
      6. 链路层
      7. 物理层

    - TCP/IP五层模型

      1. 应用层
      2. 传输层
      3. 网络层
      4. 链路层
      5. 物理层

      **应用层：**负责应用程序之间的数据沟通（HTTP/FTP/DNS/DHCP)

      **传输层：**负责端与端之间的数据传输（两个进程间，封装端口，数据从哪个进程出来去哪个进程）（TCP/UDP)

       **网络层：**负责地址管理与路由选择（哪个主机到哪个主机）（IP，路由器）

      **链路层：**相邻设备之间的数据传输（相邻两个网卡，网卡出厂时有MAC地址）（Ether，交换机：相邻设备之间数据转发）

      **物理层：**光电信号传输（以太网协议，集线器：数据信号放大）

  - 网络通信中数据的传输流程：数据封装，数据分用

  - 协议解析

    - 应用层协议：HTTP协议

      - RUL（网址）：统一资源定位符

      - url：`http://user:pass`(用户信息：不安全）`@ip:port`(端口信息，默认80端口)`@srv_add`r(服务器ip地址)`/uri`(服务器请求的资源的标识符，/为指定的子目录)`?`（间隔）`query_string`(key=val&key=val)#片段标识符

      - url编码：url中特殊字符都有特殊含义，因此用户提交数据中若存在特殊字符则需要转码（每个字符转换为16进制数字的字符串--为表明数据经过了转码，因此在旋转吗的数据前加上%）

      - url解码：在用户提交的数据中遇到%时，则对紧跟其后的连个字符转换为数字，并且第一个数字左移4位（乘16）加上第二个数字

      - http协议格式

        1. 首行：

           ​	**请求首行：**请求方法（GET:：没有正文，不是主要用于提交数据/POST：在请求头提交数	据）（不同版本方法数不同：HTTP/(0.9/1.0/1.1/2)）

           ​	**响应首行：**协议版本 响应状态码（1--/2--/3--/4--/5--、200/302/400/404/502/500）

        2. 头部：以`key：val`组成的键值对，并且键值对之间以\r\n进行间隔`key:val`\r\n`key:val`\r\n

           ​	content-Length（正文的总长度）/Content-Type（描述数据类型）/Transfer-Encoding/Location（和重定	向结合使用）/Set-Cookie（下次请求）

        3. 空行：\r\n（结合上面的检测到两个\r\n识别头部结尾）

        4. 正文：客户端提交的数据、服务端响应的数据

    - 传输层：负责端与端之间的数据传输;TCP、UDP

      - udp协议特性：无连接，不可靠，面向数据报

        **无连接、不可靠：**只要知道对端地址就可以发送数据，但是对方是否收到数据，收到的数据是否有序并不关心

        **面向数据报：**向上层交付数据时，只能一整条一整条的交付

        **udp协议字段：**16位源端口，16目的端口欧，16位数据报长度，16位校验和（二进制反码求和，相加为0则为正确信息）

        **16位数据报长度：**决定的特性

        	1. 面向数据报
         	2. udp每次直接传输的报文大小是有长度限制的64k（用户给定的传输数据长度不能大于64k-8）
              	1. 若是数据过长，需要用户在应用层进行数据分包
              	2. udp不保证数据有序，因此若是应用层分包还需要用户在应用层进行包序管理

        **udp实现的应用层协议：**DHCP

- tcp协议：面向连接，可靠传输，面向字节流

  - 连接管理（三次握手：操作系统完成，建立连接）

    - 客户端
      1. 创建套接字
      2. 为套接字绑定地址信息
      3. 向服务端发起连接请求
    - 服务端
      1. 创建套接字
      2. 为套接字绑定地址信息
      3. 开始监听（LISTEN状态）

    **建立 TCP 连接需要三次握手：**

    1. （客户端SYN SENT发送状态）即发送方发送 SYN 包（服务端处于SYN_RCVD创建套接字，等待接收SYN+ACK），
    2. 接收方接收 SYN 包并发送 SYN+ACK 包，
    3. 发送方（客户端处于ESTABLISHEO状态）接收 SYN+ACK 包发送 ACK 确认包（服务端处于ESTABLISHED状态）

    **释放 TCP 连接需要四次握手：**即发送方发送 FIN 包主动关闭连接，接收方接收 FIN 包并发送 ACK 确认包，发送方接收到 ACK 包后接收方发送 FIN 包，发送方发送 ACK 确认包

    ​	**为什么握手是三次二挥手是四次**

    ​	**握手三次：**两次不安全，有可能SYN会延迟，缺乏状态保护的情况下，收到一个SYN就会建立一个新的socket，完	成整的状态保护避免对一个客户端创建多个socket，服务端无法通过客户端的SYN确定客户端具有数据收发的能力，需要服务端再次进行确认

    ​	**挥手四次：**被动关闭方，收到fin之后对其进行ACK回复，但是不能直接关闭socket，因为这时候用户有             可能正在处理数据（socket接收缓冲区中有可能还有堆积的数据），需要用户来确认什么时候关闭socket发送fin；因此ACK和fin不能放在一起

    ​	**三次握手失败，服务端如何处理**

    ​	服务端超时等待ACK之后，向客户端发送rst报文，然后释放新建的socket资源

    ​	**SYN泛洪攻击（是什么，怎么解决）**

    ​	**主动关闭方，TIME_WAIT状态的作用:**

    1. 假设没有time_wait而是直接进入closed状态，释放socket资源会造成的危害

       在主动关闭方发送的最后一次ACK丢失的情况下

       如果主动关闭方使用相同的地址信息立即重启，但是被动关闭方有可能

       1. 收到被动关闭方超时等待后重发的fin包，对新连接造成影响
       2. 发送SYN请求，但是对方等待的是ACK，因为状态不对导致对新连接造成影响

    2. 因此主动关闭方需要等待一段时间：2个MSL时间

    ​	若是对方重发fin请求，可以对其再次进行确认回复

    ​    **MSL：**报文最大生命周期（30秒）

    ​    等待连个MSL时间是为了让***网络中延迟的报文***（后序重传的fin和ACK）都消失网络中不会对后序连接造成影响

    **大量time_wait解决方案：**调整MSL时间，设置套接字选项（地址复用）

  - 可靠传输

    面向连接

    **确认应答机制：**对每一条数据，向发送发进行确认回复，

    **超时重传机制：**发送数据后等待一段时间（200ms）若是没有收到确认回复，则认为数据丢失，进行重传

    **协议字段中的序号+确认序号：**确保数据有序的向应用层交付

    **协议字段中的校验和：**校验接收的数据是否一致，不一致则发送重传请求，否则确定回复

    **tcp为了保证可靠传输，牺牲了部分性能，（有些性能的是没必要的），比如ack丢失导致的重传，tcp又采用了几种机制来避免无谓的性能松狮以及提高性能的方法**

    1. 滑动窗口机制：

       **流量控制：**通过协议字段中的窗口大小（不会大于接收方的接收缓冲区间中剩余空间大小）字段控制发送发发送的数据大小；避免因为发送过快而接收方处理过慢导致接收缓冲区数据放满后，大量的数据丢失重传降低的性能

       窗口大小在每次对数据进行确认回复的时候都会进行重新协商

       每一条确认回复，中的确认序号，都要保证之前的数据已经完全收到，没有收到第一条回复，但是收到第二条回复，认为第一条和第二条都已经正确插损胡，避免因为ack对视而导致的数据重传。

       **快速重传机制：**收到了第二条数据，但是没有收到第一条，则初步认为第一条数据丢失，则立即发送第一条数据的重传请求，并且连续发送三次（避免因为网络阻塞，数据延迟到达而导致的重传），当发送方连续收到三次重传请求的时候，就不需要等待超时，直接对这条数据进行重传

       **拥塞控制：**网络通信开始时，并不会直接发送窗口大小的数据，而是以一种慢启动，快增长的形式进行数据传输，起到一个网络探测在作用，避免开始通信时因为网络状况不好导致的发送数据越多，对视数据越多的重传性能功能损失，在快增长的过程中，若出现丢包则初始化拥塞窗口大小，重新开始探测网络状况；

    2. **延迟应答机制：**接受方接收数据若是立即回复，则窗口大小会降低， 会导致传输速度降低，因此接收方接收到的数据后，并不立即回复，而延迟一会（不超过500ms），在这期间，用户可又能将数据从接收缓冲区中取出，可以尽最大的能力保证窗口大小，保证传输速度不会降低

    3. **捎带应答机制：**每次接收方对发送的数据进行确认回复，若单独发送一个数据报（仅仅包含一个tcp报头）是不划算的，解决方案就是将要进行的确认回复和即将要发送的数据合到一起进行发送，就可省略一个tcp报头的发送，减少网络中不必要的流量信息；

       **tcp可靠传输：**连接管理，确认一个大，超时重传，序号/确认序号，校验和滑动窗口机制（流量控制，拥塞控制，快速重传），延迟应答，捎带应答

  - 面向字节流：数据不会直接发送，而是放到缓冲区中，操作系统选择一个合适的时机将合适大小的数据发送出去，对方接收数据时可以一次性接收所有数据，也可以一次接收一点，分多次接收

    - **tcp面向字节流特性：**传输灵活，但是会造成粘包问题

      **粘包问题：**tcp传输的数据在发送缓冲区或者接收缓冲区中堆积，因为tcp数据收发的灵活性，导致有可能多条数据当做一条接收；（两条数据的粘连）

      **tcp粘包原因：**tcp在传输层，对数据的格式并不关心，对数据之间没有边界区分因此造成得到数据报

      **粘包是tcp在传输层对数据边界不敏感，因此需要用户在应用层进行数据边界管理：**

      1. 特殊字符间隔
      2. 定长数据
      3. 不定长数据应用协议头中声明数据长度

  - tcp连接管理中的保活机制

    ```
    	若是通信双方，长时间（7200s）没有数据往来，在会向对方发送保活探测数据包（要求对方对这个数据包进行回复），若是收到回复则认为连接正常，若是间隔（75s)发送连续多次（9c次）没有收到回复，则认为连接断开
    ```

    - tcp异常链接断开的情况：断电

  - tcp协议字段

    - 16位源/目的端口：负责端与端之间的数据传输
    - 32位序号/确认序号：保证数据有序交付
    - 4位头部长度：解析时获取tcp头部，以4字节为 单位（tcp头部最小20字节，最大60字节）
    - 6位标志位：URG/ACK(确认回复)/PSH/RST(重置连接)/SYN/FIN(断开连接)
    - 16窗口大小：实现活动窗口，以及进行流量控制
    - 16位校验和：保证数据一致性
    - 16位紧急指针：带外数据
    - 40字节的选项数据：可有可无

- 网络层：负责地质管理与路由选择；IP；路由器

  - **路由选择：**在复杂的网络环境中为每一条数据都选择一条合适的路径

    - 在网络中的IP地质不能随意分配，因为随意分配很容易造成IP地质冲突，一次IP地质需要得到合理的管理才可以
    - 一个路由器可以组件一个局域网，这时候路由器向局域网中的主机分配IP地质的时候，就必须带有自己网络的表示---网络号（网段），这时候只需要将每个网络的网络号规范起来就可以避免IP地址冲突
    - 在一个局域网中，路由器向主机分配IP地址，还要能够在局域网中标识这个主机，这个表示叫主机号
    - IP的组成：网络号+主机号
    - 保证相邻的网络不能具有相同的网络号就可以尽可能的避免IP地址冲突

  - **网段的划分：**

    - 早期划分方式：A/B/C/D/E

      - A类地址：低24位是主机号，A类网络地址主机号有2^24，地址范围：	

        ```
        0.0.0.0~127.255.255.255
        ```

      - B类地址：低16位时主机号，B类网络地址主机有65536个，地址范围：

        ```
        128.0.0.0~191.255.255.255
        ```

      - C类地址：低8位时主机号，C类网络地址主机号有256个，地址范围：

        ```
        192.0.0.0~223.255.255.255
        ```

      - D类地址：

        ```
        224.0.0.0~239.255.255.255
        ```

      - E类地址：

        ```
        240.0.0.0~247.255.255.255
        ```

    - **现在解决方案-CIDR：**加入了一个字段叫子网掩码，通过子网掩码来对网络进行划分

      - **子网掩码：**由一串连续的二进制1组成的一个无符号4个字节的整数

        192.168.132				 255.255.255.0

        **作用：**

        1. 子网掩码与IP地址相与能够得到网络号

           ```
           192.168.122.132&255.255.255.0=192.168.122.0
           ```

        2. 子网掩码取反，可以得到网络中主机号的个数~255.255.255.0=255+1=256

        - **现在有一个C类网络地址，将这个C类网络划分出20个子网，请问每个子网的子网掩码是多少，IP地址范围是多少，以及各自网络的网络号是多少**

        ​		C类网络地址有256个主机号，平均划分20个子网，每隔子网中主机号个数256/20，每个子网中主机号个数是12；每个子网掩码是连续的1，因此12取反无法得到连续1，在每个子网主机号能少，不能多的情况下，为了保证子网掩码是连续的1，因此主机号个数最好是8，得到最大主机号7

        ~0.0.0.7=255.255.255.248 --- 这就是每个子网的子网掩码

        - **现在有一个C类网络地址，将这个C类网络划分出4个子网，请问每个子网的子网掩码是多少，IP地址范围是多少，以及各自网络的网络号是多少**

          ```
          256  / 4 = 64 每个子网中最大主机号是63
          
          63取反就能得到每个网络的子网掩码 ~0.0.0.63 = 255.255.255.192
          
          192.168.122.0 ~ 192.168.122.63				192.168.122.0 
          
          192.168.122.64 ~ 192.168.122.127			192.168.122.64
          
          192.168.122.128 ~ 192.168.122.191		  192.168.122.128 
          
          192.168.122.192 ~ 192.168.122.255          192.168.122.192
          ```

          

        - 在一个网络中，并不是所有主机号都能分配个主机（2个不能分配，主机号 - 2 = 可分配地址）

          - 主机号全为0的IP地址 -- 网络号，用于表示一个网络
          - 主机号权威1的IP地址 -- udp广播地址
          - **127.0.0.1		本机虚拟会还网卡地址 --- 用于本机的网络测试**

        - 在RFC1918中进行规定，用于组建私网的网段也不能随意使用，只能在一下几个网段能够用于组建私网

          ```
          10.-.-.-		172.16.-.- ~ 172.31.-.- 		192.168.-.-
          
          相邻的网络不能使用相同的网络号
          ```

        - 路由选择

          - **路由表：**每个路由器上都有一个路由表，记录的连接在路由器上的网络

            ```
            Destinnation		Gateway			Genmask				Iface
            
            192.168.122.0						255.255.255.0		eth1
            
            192.168.10.0						255.255.255.0		eth0
            ```

- IP协议字段

  - **4位版本：**IPV4/IPV6

  - **4位头部长度：**IP报文头最大长度60个字节（以4字节为单位）

  - **8位服务类型：**4位TOS字段（最小延时/最大吞吐量/最高可靠习性/最小成本），1位保留位

  - **16位报文长度：**限制一个IP报文最大长度64k ，udp数据最大长度：64k-20-8

    ```
    MTU:最大传输单元 < udp数据长度 < 64k-20-8时，链路层则不支持大于mtu大小数据传输，这时候网络线获取下层mtu大小，在网络层对数据进行分片
    ```

  - **16位标识：**udp数据有可能在网络层进行数据分片，这个表示则可以指定当前分片属于哪个udp数据包

  - **3位标志：**1位启用，1位标识是否禁止分片，1位用于标识分片末尾

  - **13位片偏移：**用于指定udp数据分片相对于udp数据报起始位置的偏移量（分片在数据包中的位置）

    - 偏移量是以8字节为单位，每个分片都是8的整数倍长度（除最后一个分片）

  - **8位ttl：**报文生命周期，最大经过的路由器跳数

  - **8位上层协议：**用于数据分用时，决定由上层哪个协议进行解析

  - **16位校验和：**校验数据一致性

  - **32位源/目的IP地址：**标识数据从哪来到哪去

  - **40字节选项数据**

- 链路层：负责相邻设备之间的数据传输；Ether；交换机
  - **链路层协议字段：**源MAC地址，目的MAC地址，上层协议类型，数据，帧尾
  - **MAC地址：**网络物理硬件地址，用于表示硬件设备
    - **mtu对tcp协议的影响：**tcp在传输层的时候就会获取mtu大小进行计算得到自己的mss大小，并于对方进行协商，取其中较小的一个作为传输大小，发送数据的时候从发送缓冲区中取出的数据大小就不会大于mss大小，tcp在传输层会进行数据分段，因此不会在网络层进行数据分片
    - **mtu对udp协议的影响：**因为udp在传输层不会进行数据分段，因此当啊udp传输的数据大小，大于mtu但是小于64k-20-8的时候，数据会在网络层进行数据分片，分片了再对端就会进行分片重组，只要有一个分片出现问题，都会导致整个udp数据报被丢弃；因此对于udp来说分片越多，传输就越危险，因此用户在应用层进行udp数据分包的时候最好就将数据大小控制在mtu-20-8

- 

  

  

  

  

  



