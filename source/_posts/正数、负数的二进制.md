---
title: 正数、负数的二进制
date: 2019-06-01 17:38:23
tags: java
---

##### 先看一下我在网上看到的一个二进制加法(讲解的很容易懂)

1. **原码：**在数值前直接加一符号位的表示法。
2. **反码：**
   **正数：**正数的反码与原码相同。
   **负数：**负数的反码，符号位为 “1”，数值部分按位取反。
3. **补码：**
   **正数：**正数的补码和原码相同。

**负数：**负数的补码则是符号位为 “1”。数值部分按位取反后再在最低位加 1。也就是 “反码 + 1”。5-3 计算过程

- 以字长 8bit 为例

  5 - 3 = (0000 0101) 补 + (1000 0011) 补 = 0000 0101 + 1111 1101 (这里就是反码为 1111 1100，+1 得到) =
  1 0000 0010
  最后，这里字长为 8bit，所以 8 位以后的都舍弃（从右边开始数）
  PS: 如果舍弃掉的是有效数字，那么这就是传说中的溢出

  **结果：** (0000 0010) 2=(2) 10
  所以 5-3=2

##### 再看一下我在程序的遇到的问题

```java
System.out.println("(byte) 127:" + (byte) 127);
System.out.println("(byte) 128:" + (byte) 128);
System.out.println("(byte) -128:" + (byte) -128);
System.out.println("(byte) -127:" + (byte) -127);
System.out.println("(byte) -1:" + (byte) -1);
```

###### 结果如下

```java
(byte) 127:127
(byte) 128:-128
(byte) -128:-128
(byte) -127:-127
(byte) -1:-1
```

可以看到`(byte) 128:-128`，

###### 解释

这是因为，127 -->原码、反码、补码： 0111  1111

​                    127 + 1 -->1000  0000

byte类型一共8个bit位，在计算机中负数的二进制表示为补码。而1000  0000正是-128的补码

###### 转换过程

-128，不能按照数值位前直接加一个符号位，要从128开始，其他的负数可以按照这一规律计算

- 原码：1000  0000 (-128，进位被舍去)

- 反码：1111  1111

- 补码：1000  0000

  补码计算为： (11111111 (反码) + 1=10000000, 这里实际上真正相加的是 11111111 后面的 7 位，**第 1 位是符号位始终不会变**，所以，**当进到第 8 位的时候，就表示溢出了，会被舍弃**。

  **0 只有一个补码 00000000，那么 10000000 就不会表示成 - 0 的补码，即：补码 1000 0000 唯一的表示是 - 128，在补码中用 (-128) 代替了 (-0), 所以补码的表示范围为: (-128~0~127) 共 256 个.**

int为4个字节，byte为1个字节，int转byte只能取低八位补码：1000  0000

**实际上，int型的负数，在一个字节的基础上前面补1即可，计算过程同普通的负数，没有发生溢出**

```java
-128：
	1111  1111  1111  1111  
	1111  1111  1111  1111
	1111  1111  1111  1111
	1111  1111  1000  0000
```

普通负数-1：

- 原码：1000  0001
- 反码：1111  1110
- 补码：1111  1111



