---
title: 学习记录
date: 2019-05-25 00:18:56
tags: notes
---

##### 栈和堆的具体存储总结(0524) 类变量在堆区，方法变量在栈区

- this总结
- main函数中的变量必须先赋值,类变量可以不赋值有默认值,总结一下变量初始化以及变量默认值
- ConcurrentHashMap 如何保证线程安全，使用CAS保证，不是 synchronized https://www.cnblogs.com/junjiang3/p/8686290.html
- java复制数组哪种效率更高https://www.nowcoder.com/questionTerminal/915a9a1f5a3a4a6bbe5011c090bdf137
- SimpleDateFormat 的线程安全问题，并发环境下使用 SimpleDateFormat 的 parse 方法有线程安全问题 https://blog.csdn.net/weixin_38810239/article/details/79941964
- 泛型擦除https://blog.csdn.net/hui_lang/article/details/7552564
- join(),sleep()复习
- 在异常处理中,try块不可省略,可以使用多重catch块,finally块可以省略,catch块和finally块不可以同时省略.

#### 0524

- 动态规划问题,神奇的口袋,总量为40,求解有多少中方式的问题
- 构造块执行顺序详解,继承关系代码块执行总结,静态块,构造块 https://blog.csdn.net/lahand/article/details/80310313
- true ? false : true == true ? false : false ---> false
- Math.round(x); x 为正小数时,四舍五入.x为负小数,数字部分五舍六入
- 快排思想找到数组中的第k个大的元素

#### 0528

- 如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法
- JUnit主要用来完成单元测试
- 大数阶乘，不用BigDecimal试一下
- String 类函数toUpperCase()不改变调用者本身
- java.lang
- Java 中多个异常的捕获顺序 (多个 catch)
- 结构型模式中最体现扩展性的模式是 装饰模式
- public final static native int w() 声明是错误的
- byte 类型进行加操作得到的是int类型，若想将连个byte类型变量相加赋值给第三个byte类型，必须强转
- byte类型

#### 0531

- 构建乘积数组
- 总结一下StringBuffer的引用传递问题

#### 0601

- 腾讯笔试题格雷码(递归)

#### 0604

- local variable:临时变量

#### 0603

- 程序计数器，线程隔离，静态变量存储区，方法区流媒体技术是一种可以使音频，视频和其他多媒体信息在Internet及Intranet上以实时的，无需下载等待的方式进行播放的技术
- java在运行时才进行翻译指令，java编译出来的目标文件不可以运行在任意jvm上
- 大数加法

#### 0605

- 另类加法，不使用相关数学运算符号
- 饥饿的小易
- 类方法中可以调用实例方法，类方法中可以直接调用本类的的类方法
- 类加载的时候加载了什么。int类型对象成员变量赋予默认值不属于类加载

#### 0606

- 如果希望监听TCP端口9000，服务器端创建socket。new ServerSocket(9000)
- jre判断程序是否执行结束的标准是，所有前台线程执行完毕
- java运算符的结合性和优先级，i= 5，s = (i++) + (++i) + (i--) +(--i) = 24
- instanceof运算符可以用来判断一个对象是否为一个类的实例，一个实现指定接口的类的实例，一个子类的实例
    )

#### 0607

- jdk 1.6 垃圾回收器 https://blog.csdn.net/sunshineboy_oo/article/details/49206781

#### 0608

- [java 反射中 getDeclaredMethods 和 getMethods 的区别](https://blog.csdn.net/hanxueyu666/article/details/71502143)
- [java.lang包](https://www.cnblogs.com/zedosu/p/6518124.html)

#### 0610

- 中缀表达式运算。中缀表达式转后缀表达式。后缀表达式计算。当操作数不止一位的时候的运算
- 手撸kmp
- 假设你有100Mb的内存，需要对1Gb的数据进行排序，最合适的算法是：归并排序

#### 0611

- 数据有序的情况下，各排序快慢
- 总结一下TreeSet存储自定义类按任意排序方式存储信息(已实现)
- 若栈采用顺序存储方式存储，现两栈共享空间V[1..m]，top[i]代表第i个栈( i =1,2)栈顶，栈1的底在v[1]，栈2的底在V[m]，则栈满的条件是（top[1] + top[2] = m）。**top[1]、top[2]应该代表栈中的元素个数**
    以下哪种排序算法对(1,3,2,4,5,6,7,8,9)进行的排序最快？-->冒泡排序 （快排，归并，堆排）。近似有序的数据，排序复杂度分析一下

#### 0612

> 坑啊

- 有权值的叶子节点生成的哈夫曼树，求带权长度

```java
给定下列程序，那么执行printf("%d\n", foo(20, 13));的输出结果是________。
A 3
B 9
C 27
D 81
他的回答： C (错误)
正确答案： D
参考答案：
解析：foo(20, 13) = 3 * foo(14, 6) = 3 * 3 * foo(8, 3) = 3 * 3 * 3 * foo(2, 1) = 3 * 3 * 3 * 3 * foo(-4, 0) =3 * 3 * 3 * 3 * 1 = 81
答案：D
```

- 要连通具有 **n** 个顶点的有向图，最少需要（n）条边。

> 13/14/15没做

#### 0702

- 处于运行状态的操作系统应放在主存中

    ```java
    下列选项中，会导致进程从执行态变为就绪态的事件是（）。
    
    执行 P(wait)操作
    申请内存失败
    启动 I/O 设备
    被高优先级进程抢占
    ```

    

[执行态变为就绪态事件]: https://www.nowcoder.com/questionTerminal/7bbb278a8c6441b9b0e5f97574f2d8d8

- 现代操作系统中利用缓冲技术的主要目的是:提高CPU和设备之间的并行程度
- 进程和程序的一个本质区别是:前者为动态的,后者为静态的
- 一个进程的读磁区操作完成后，操作系统针对该进程必做的是:修改进程状态为就绪态
- 选择在最近的过去很久未访问的页面予以淘汰的算法称为:LRU
- 并发进程之间:可能需要同步或互斥
- 一次 I/O 操作的结束，有可能导致:一个进程由睡眠变为就绪

#### 0705

- 若一个用户进程通过 read 系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是（ ）。

    ```java
    Ⅰ． 若该文件的数据不在内存中，则该进程进入睡眠等待状态 
    Ⅱ． 请求 read 系统调用会导致 CPU 从用户态切换到核心态 
    Ⅲ． read 系统调用的参数应包含文件的名称
    仅Ⅰ、 Ⅱ
    ```

- Linux 文件权限一共 10 位长度，分成四段，第三段表示的内容是 

    > 10 位分成 4 段，第 1 段 1 位，后面每 3 位一段，分别表示文件类型 / 文件所有者权限 / 文件所有者所在组的权限 / 其他用户的权限

- 进程阻塞的原因有

    - 等待I/O

    - 进程sleep

    - 等待解锁

        不包括时间片切换

        **解析：**进程有 3 个状态：就绪态。执行态、阻塞态。三种状态的转换包含有：

        就绪 -> 执行，执行 -> 就绪，执行 -> 阻塞，阻塞 -> 就绪

        等待 I/O、进程 sleep、等待解锁等原因都会导致进程暂停。关于 "时间片切换"，当进程已经获得了除 cpu 外所有的资源，这时的状态就是就绪态，当分配到了时间片就成了执行态，当时间片用完之前一直未进入阻塞态的话，此后便继续进入就绪态。所以进程的就绪与阻塞是完全不同的

- 在缺页处理的过程中，操作系统执行的操作可能是

    - 修改页表
    - 磁盘I/O
    - 分配页框

- 下列选项中，满足短任务优先且不会发生饥饿现象的调度算法是

    - 高响应比优先

    > D 选项会产生饥饿现象，A、C 选项，不满足短作业优先，B 选项，由于响应比 =(作业执行时间+作业等待时间)／作业执行时间。高响应比调度算法在等待时间相同的情况下，作业执行时间越短响应比越高，满足短任务优先。随着等待时间增加，响应比也会变大，执行机会就增大，所以不会产生饥饿现象，  

- 下列选项中，降低进程优先级的合理 时机 是 (A) 

    - 进程的时间片用完

- 进程刚完成I/O，进入就绪列队
- 进程持久处于就绪列队

- 进程从就绪状态转为运行态

> B 他已经进入就绪状态了。
>
> C 原因 长期在就绪也就是等待，再不升高优先级就要饿死了 
>
> D 人家刚运行，你就降低，有可能会被抢断。

- 在使用锁保证线程安全时，可能会出现活跃度失败的情况，活跃度失败主要包括(死锁、饥饿、活锁)
- 在使用锁保证现场安全时可能会出现 活跃度 失败的情况主要包括 饥饿、丢失信号、和活锁、死锁 等。【多线程除了死锁之外遇到最多的就是活跃度问题了】
    - **饥饿   ：**指线程需要访问的资源   被永久拒绝   ，以至于不能再继续进行。解决饥饿问题需要平衡线程对资源的竞争，如线程的优先级、任务的权重、执行的周期等。 进程饥饿，即为 Starvation，指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。
    - **活锁   ：**指线程虽然没有被阻塞，但由于某种条件不满足，一直尝试重试却始终失败。解决活锁问题需要对   重试机制   引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试，这会大大减少碰撞的可能性。 活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试
- 进程调度算法
    - 先来先服务调度算法（FCFS）
        就是先到先得，换一个说法就是等待时间最长的先采用  
    - 短进程先执行（sjf）      
        执行时间短的优先执行     
    - 多级反馈轮转      
        时间片轮转，进程轮转执行      
    - 优先级法    
            分为静态优先级：优先级已经设，按照顺序执行就行     
            动态优先级：随着执行的过程，比如占用系统资源，等待时间等，优先级会随着改变    
    - 最高响应比优先法（HRN）     
        是对 FCFS 和 SJF 的平衡，R=(W+T)/T=1+W/T，w 响应时间  t 运行时间响应时间就是等待时间，运行时间是估计运行时间的长
- 如何减少换页错误？
    - 进程倾向于占用CPU
    - 访问局部性（locality of reference）满足进程要求--√
    - 进程倾向于占用I/O
    - 使用基于最短剩余时间（shortest remaining time）的调度机制
- 通常所说的 "存储保护" 的基本含义是
    - 防止程序间相互越界访问
- 

#### 0707

- 动态规划
- 错排，排列组合问题
- 竞争可能引起死锁
    - 产生死锁的原因主要是：
        1. 因为系统资源不足。
        2. 进程运行推进的顺序不合适。
        3. 资源分配不当等。
    - 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则
        就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。
        **产生死锁的四个必要条件：**
        1. 互斥条件：一个资源每次只能被一个进程使用。
        2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
        3. 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
        4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
            这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
            一不满足，就不会发生死锁。
            **死锁的解除与预防：**
    - 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和
        解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确
        定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态
        的情况下占用资源。因此，对资源的分配要给予合理的规划。
- 并发是同时执行不过微观上是串行的，并行是同时执行，但是是不同的处理器执行
- 属于同一进程的多个线程之间的切换不会引起进程的切换，只有属于不同进程的线程之间的切换才会引起进程的切换。
- 在 Unix 系统中，处于 (内存就绪) 状态的进程最容易被执行。
- 进程的控制信息和描述信息存放在 (PCB)。
- 当系统发生抖动（thrashing）时，可以采取的有效措施是 
    1. 撤销部分进程 
    2. 增加磁盘交换区的容量 
    3. 提高用户进程的优先级 
        **发生 “抖动” 的根本原因是：**
        - 同时在系统中运行的进程太多 ，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内 存。
            太多的话， 最直接有效的方法当然是撤销部分进程。

#### 0708

- 在 OSI 分层模型中，把传输的比特流划分为帧，是哪一层的功能（数据链路层 ）
    - 传输层的数据叫段  网络层叫包      数据链路层叫帧   物理层叫比特流
- 下面关于源端口地址和目标端口地址的描述中，正确的是（ ）
    - 在TCP/UDP传输段中，源端口地址和目的端口地址是不能相同的，否则就会建立自己到自己的连接，白白耗费资源。网络攻击中的 LAND 攻击就是利用这个这一点进行攻击的。
- 网段地址 154.27.0.0 的网络。若不做子网划分，能支持（）台主机
    - 65534     B 类地址，前 16 位为网络号，后 16 为主机号，主机个数是 2 的 16 次方减去全 0，全 1 的，为 65534 个
- SNMP 使用 udp 161 和 162 端口，则该协议属于 TCP/IP 模型中的（）
    - SNMP simple network management protocol 简单网络管理协议是一个网络管理员用来管理的工具相当于  一个 app 所以是应用层
- 主机 A 向主机 B 连续发送了两个 TCP 报文段，其序号分包是 70 和 100 ，如果 A 发送的第一个报文段丢失了，但第二个报文段达到了 B ， B 在第二个报文段到达后向 A 发送确认，那么这个确认号是多少？
    - 答案是 70，确认号指的是接收方想要接收的报文段的序号，比如我想要 1-5 的报文，在接收过程中我收到了 2-5，而 1 丢了，这时候我肯定跟你说，再发一遍 1，就是这个意思。在这里序号 70 的丢了，所以确认号就是 70，和后面的没关系。

#### 0711

- 2的个数（时间复杂度太高）

#### 0710

- /etc/resolv.conf的用途是

> DNS 解析的设置文件在： /etc/resolv.conf
> 邮件服务的设置文件： /etc/mail.rc
> DHCP 的设置文件： /etc/dhcpd.conf
> 网络路由的设置文件： /etc/gateways

- 能够PING通同网段的节点，但却如PING不通其他网段的所有节点的最可能的原因(本机网关设置错误)
    - ping 是 TCP/IP 协议族的一部分，其属于网络层协议。主要是用来检测网络是否通畅。如果要 ping 其他网段则需要设置网关。
- 常被提及的Dos攻击的是以下的行为(发送无效的请求，使得正确的请求无法被响应)
- 以下不是 DNS 服务的作用的是(将IP解析成MAC地址)
    - DNS 是域名解析协议,IP 地址转换成 MAC 地址是 ARP 协议的作用
- 在小红书公司的局域网中，署队长的私人电脑可以查看到的同事的电脑，也成功了登录了 QQ，但无法访问到公司的站点 "http://www.xiaohongshu.com”, 请协助署队长查找最有可能出现的问题的地方是？
    - 能上 QQ，上不了网页，是因为解析不了域名，也就是 DNS 相关出了问题
- 将一个 C 类网络划分 20 个子网，最适合的子网掩码是多少（255.255.255.248）

> 首先 2^4<20<2^5 所以至少需要 5 位来表示网络号（向主机号借 5 位），	也就是说子网掩码部分应该是 11111111 11111111 11111111 11111000 也就是 255.255.255.248

- 302 临时重定向，会产生两次 http 请求，软件开发中一般用于跨域请求先请求跨域凭证，再访问跨域后的网络资源。

- 局域网的网络地址 192.168.1.0/24，局域网络连接其它网络的网关地址是 192.168.1.1。主机 192.168.1.20 访问 172.16.1.0/24 网络时，其路由设置正确的是？

    - route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1
    - 路由中添加一条路由 网关 192.168.1.1 掩码 255.255.255.0(二进制有24个1) 到达距离 1hops
    - -net 后面跟的是目标网络，gw 就是 gateway（网关入口）就是你从哪个网关去到那个目标网络。

- 建立一条TCP连接需要（）个步骤，关闭一个TCP连接需要（）个步骤

    - 建立 TCP 连接需要三次握手：即发送方发送 SYN 包，接收方接收 SYN 包并发送 SYN+ACK 包，发送方接收 SYN+ACK 包发送 ACK 确认包
    - 释放 TCP 连接需要四次握手：即发送方发送 FIN 包主动关闭连接，接收方接收 FIN 包并发送 ACK 确认包，发送方接收到 ACK 包后接收方发送 FIN 包，发送方发送 ACK 确认包

- 上网的时候，访问某个网页却突然出现了某个运营商的网页（如联通、电信）。出现此问题可能的原因是?（DNS劫持）

    - DNS 劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的 IP 地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。

- TCP 协议的主要功能是完成对数据报的确认、流量控制和网络拥塞；自动检测数据报，并提供错误重发的功能  ；将多条路径传送的数据报按照原来的顺序进行排列，并对重复数据进行择取；控制超时重发，自动调整超时值；提供自动恢复丢失数据的功能。因此，除 TCP 功能以外需要程序员考虑的为发送数据的格式及应用层协议

- POP3 建立在 TCP 连接上，使用的是有连接可靠的数据传输服务。

- 主机甲与主机乙之间已建立一个 TCP 连接，双方持续有数据传输，且数据无差错与丢失。若甲收到 1 个来自乙的 TCP 段，该段的序号为 1913、确认序号为 2046、有效载荷为 100 字节，则甲立即发送给乙的 TCP 段的序号和确认序号分别是（ 2046、 2013）。 

    - 甲在发送数据之前，明确两个信息：1. 段序号为 1913，说明 乙 发给 甲 的数据段起始字节序号为 1913，有效载荷长度为 100，说明该数据段的长度为 100，那么甲下次需要的数据段的序号就是 1913 + 100 = 2013；2. 乙 发给 甲 的确认序号为 2046，说明 乙 这次需要 甲 发送的数据段的起始字节序号为 2046。获取这两个信息后，甲 即可确定要发给 乙 的序号为 2046（从乙的确认序号获知），确认序号为 2013（希望下次乙能够发送首字节序号 2013 的数据段过来）。

- tcp 套接字中，不会阻塞的是哪一种操作

    ```
    TCP 的套接字 = IP + 端口号
    套接字有三种：1. 流式套接字（ SOCK_STREAM ）；2： 数据报套接字（ SOCK_DGRAM ）；3. 原始套接字（ SOCK_RAW ）
    基于 TCP 的 socket 编程是采用的流式套接字。
    分为以下步骤：
    1 ：加载套接字库，创建套接字 (WSAStartup()/socket()) ；
    
    2 ：绑定套接字到一个 IP 地址和一个端口上 (bind()) ；
    
    3 ：将套接字设置为监听模式等待连接请求 (listen()) ；
    
    4 ：请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字 (accept()) ；
    
    5 ：用返回的套接字和客户端进行通信 (send()/recv()) ；
    
    6 ：返回，等待另一连接请求；
    
    7 ：关闭套接字，关闭加载的套接字库 (closesocket()/WSACleanup()) 。
    ```

    ```
    bind只是将特定的 ip 或端口与这个套接字绑定并不会阻塞，而 read write 和 accept 这些方法会引起阻塞，读和写这些都是耗时操作，且数据流没关闭的情况下会一直阻塞这等待下一个数据包发送过来，而 accept 是等到客户端 连接，这个如果没有连接也一直阻塞着。
    ```

- 当一台 PC 从一个网络移到另一个网络时，以下说法正确的是？

    - 它的IP地址会改变，MAC地址不会改变

    ```
    当一主机移动到另一个网络时，因为各个网络的网络地址不同，因此 IP 地址会发生改变；而 MAC 地址固化在网卡中，全球惟一，不会发生变化。
    ```

- PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序。Ping 发送一个 ICMP（Internet Control Messages Protocol）即因特网信报控制协议；  

    ```
    TCP、UDP 属于传输层，ICMP 、IP 属于网络层协议，而 ICMP 主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到 IP 数据无法访问目标、IP 路由器 无法按当前的传输速率转发 数据包 等情况时，会自动发送 ICMP 消息。ICMP 报文在 IP 帧结构的首部协议类型字段（Protocol 8bit) 的值 =1.
    ```

- Host 文件作用是网址域名与其对应的IP地址建立一个关联"数据库"

- ip 地址是 32 位每 8 位为一组的二进制码，由题 10.174.20.176/28，指前 28 位不变，即（10.174.20. 不变，还有 4 位不变，这四位的二进制根据 176 知位 1011），故，对此网段的有效 ip 为：10.174.20.1011   0000~10.174.20.1011   1111，排出全 0 和全 1 不能用，则 ip 为：10.174.20.177~10.174.20.190（去掉.176 和.191）

# 0716

- 小青蛙走迷宫（滴滴算法）

- 洪水攻击要明白这种攻击的基本原理，还是要从 TCP 连接建立的过程开始说起：

    ```
    大家都知道，TCP 与 UDP 不同，它是基于连接的，也就是说：为了在服务端和客户端之间传送 TCP 数据，必须先建立一个虚拟电路，也就是 TCP 连接，建立 TCP 连接的标准过程是这样的：
    首先，请求端（客户端）发送一个包含 SYN 标志的 TCP 报文，SYN 即同步（Synchronize），同步报文会指明客户端使用的端口以及 TCP 连接的初始序号；
    第二步，服务器在收到客户端的 SYN 报文后，将返回一个 SYN+ACK 的报文，表示客户端的请求被接受，同时 TCP 序号被加一，ACK 即确认（Acknowledgment）。
    第三步，客户端也返回一个确认报文 ACK 给服务器端，同样 TCP 序列号被加一，到此一个 TCP 连接完成。
    以上的连接过程在 TCP 协议中被称为三次握手（Three-way Handshake）。
    问题就出在 TCP 连接的三次握手中，假设一个用户向服务器发送了 SYN 报文后突然死机或掉线，那么服务器在发出 SYN+ACK 应答报文后是无法收到客户端的 ACK 报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送 SYN+ACK 给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为 SYN Timeout，一般来说这个时间是分钟的数量级（大约为 30 秒 - 2 分钟）；一个用户出现异常导致服务器的一个线程等待 1 分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源 ---- 数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的 CPU 时间和内存，何况还要不断对这个列表中的 IP 进行 SYN+ACK 的重试。实际上如果服务器的 TCP/IP 栈不够强大，最后的结果往往是堆栈溢出崩溃 --- 即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的 TCP 连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了 SYN Flood 攻击（SYN 洪水攻击）。
    ```

- 下列哪个 IP 地址可以分配给一台计算机？

    - ```
        256.1.3.4
        
        ```

    - ```
        197.3.11.0
        ```

    - ```
        199.5.89
        ```

    - ```
        11.15.33.235
        ```

    ```
    互联网的网络地址分为 A~E 五类，其中
    A 类地址：0.0.0.0 ~ 127.255.255.255
         8bit 网络号 + 24bit 主机号
         
    B 类地址：128.0.0.0 ~ 191.255.255.255
    	16bit 网络号 + 16bit 主机号
    	
    C 类地址：192.0.0.0 ~ 223.255.255.255
    	24bit 网络号 + 8bit 主机号
    	
    D 类地址：224.0.0.0 ~ 239.255.255.255
    	后 28 位为多播组号
    	
    E 类地址：240.0.0.0 ~ 255.255.255.255
    	后 27 位待用
    
    分类的 IP 地址由：网络号 + 主机号组成，主要分为 A、B、C、D、E 五类，我们能使用的只有 A~C 类，D 类为多播地址，E 类保留使用。
    
    答案 A 中，256 的点分十进制 IP 地址不存在，最大为 255
    答案 B 中，197 的网络号对应 C 类地址，不能使用全 0 的主机号
    答案 C 不符合表述
    答案 D 是符合的 A 类地址
    ```

- 以下哪个 ip 不和 10.11.12.91/28 处于同一个子网

    - ```
        10.11.12.85/28
        ```

    - ```
        10.11.12.88/28
        
        ```

    - ```
        10.11.12.94/28
        
        ```

    - ```
        10.11.12.97/28
        
        ```

    ```
    前 28 位为网络号，故子网掩码为 11111111.11111111. 11111111. 11110000（255.255.255.240）。
    256-240=16，有 16 个子网，每一个子网段大小范围是 16。
    10.11.12.91/28 中 91 可以表示为：01011011，前四位为网络号，后四位为主机号，
    故包含 10.11.12.91 的子网范围是：01010000~01011111（80~95）。
    去掉第一个和最后一个，和 10.11.12.91/28 在一个网段的范围为： 10.11.12.81/28~ 10.11.12.94/28。
    答案选择 D。
    
    ```

- 假设在 x86 平台上，有一个 int 型变量，在内存中的内部由低到高分别是：0x12,0x34,0x56,0x78 当通过网络发送该数据时，正确的发送顺序是 ()

    - ```
        0x12,0x34,0x56,0x78
        
        ```

    - ```
        0x78,0x56,0x34,0x12
        
        ```

    - ```
        0x34,0x12,0x78,0x56
        
        ```

    - ```
        0x56,0x78,0x12,0x34
        
        ```

```
X86 系列 CPU 都是 little－endian 的，所以 int 型变量值为 0x78563412, 网络发送数据时，采用大段，先发送高位再发送低位 
小端法 (Little-Endian) 就是低位字节排放在内存的低地址端 (即该值的起始地址), 高位字节排放在内存的高地址端；
大端法 (Big-Endian) 就是高位字节排放在内存的低地址端 (即该值的起始地址), 低位字节排放在内存的高地址端；

```

- 下列有关 Socket 的说法，错误的是（B）

    ```
      Socket用于描述IP地址和端口，是一个通信链的句柄
      Socket通信必须建立连结
      Socket客户端的端口是不固定的
      Socket服务端的端口是固定的
    
    ```

    ```
    IPV4 下，两种基本的通信方式分别是 TCP 和 UDP，前者是面向连接的可靠的字节流服务，通信之前必须要先建立起 socket 连接，而后者是面向无连接的数据包服务，通信之前无需建立起任何连接，因而 B 选项是错误的
    
    ```

- 关于 ARP 表，以下描述中正确的是（C）

    - ```
        用于在各个子网之间进行路由选择
        
        ```

    - ```
        提供常用目标地址的快捷方式来减少网络流量
        
        ```

    - ```
        用于建立IP地址到MAC地址的映射
        
        ```

    - ```
        用于进行应用层信息的转换
        
        ```

```
  ARP 是地址解析协议，工作在网络层，简单语言解释一下工作原理。
  
  1：首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系。
  
  2：当源主机要发送数据时，首先检查 ARP 列表中是否有对应 IP 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包，该数据包包括的内容有：源主机  IP 地址，源主机 MAC 地址，目的主机的 IP  地址。
  
  3：当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。
  
  4：源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。
  
  广播发送 ARP 请求，单播发送 ARP 响应。
  
  地址解析协议， 即 ARP （Address Resolution Protocol） 是根据 IP 地址获取物理地址的一个 TCP/IP 协议。 主机 发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。
```

- 下面有关 Cookie 的说法，错误的是(C)

    - ```
        Cookie不是只有一个
        ```

    - ```
        Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie
        ```

    - ```
        在HTTP请求中的Cookie是密文传递的
        ```

    - ```
        有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私
        ```

    **HTTP 的 cookie 是明文传送的，HTTPS 的 cooike 是密文传送的。**

- 下面对于 cookie 的描述中错误的是？(A)

    - ```
        Cookie通过HTTP Headers从浏览器端发送到服务器端并存储在服务器端
        ```

    - ```
        Cookie的大小限制在4kb左右，对于复杂的存储需求来说是不够用的
        ```

    - ```
        如果在一台计算机中安装多个浏览器，每个浏览器都会以独立的空间存放cookie
        ```

    - ```
        由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题
        ```

- 在网络应用测试中，网络延迟是一个重要指标。以下关于网络延迟的理解，正确的是？

    - ```
        指从报文开始进入网络到它开始离开网络之间的时间
        ```

- 在网络应用测试中，网络延迟是一个重要指标。以下关于网络延迟的理解，正确的是？(D)

    - ```
        指响应时间
        
        ```

    - ```
        指报文从客户端发出到客户端接收到服务器响应的间隔时间
        
        ```

    - ```
        指报文在网络上的传输时间
        
        ```

    - ```
        指从报文开始进入网络到它开始离开网络之间的时间
        
        ```

    ```
    B 选项应该是往返时延。RTT (Round-Trip Time): 往返时延：在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。
    网络延迟是指各式各样的数据在 网络介质 中通过 网络协议 (如 TCP/IP) 进行传输， 在 传输介质 中传输所用的时间，即从 报文 开始进入网络到它开始离开网络之间的时间。
    ```

- 在以下协议中，那个协议与其他协议是不属于同一类的 (B)

    - ```
        FTP
        ```

    - ```
        ICMP
        ```

    - ```
        TELNET
        ```

    - ```
        SMTP
        ```

    - ```
        DNS
        ```

    ```
    网络层：IP 协议、ICMP 协议、ARP 协议、RARP 协议。
    
    传输层：UDP 协议、TCP 协议。
    
    应用层：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3 协议（邮局协议），HTTP 协议， SNMP 协议， TFTP。 	
    
    ARP 协议要是按照 OSI 模型分的话应该在链路层 要是按照 TCP/IP 协议 那就在网络层
    
    SMTP：简单邮件传输协议，基于 TCP/IP 协议族的应用层协议
    FTP：文件传输协议，应用层协议
    TELNET：用于远程登录网络计算机的一种协议，应用层
    DNS：域名服务系统，在 Internet 上将域名和 ip 地址对应起来的一种协议，可以使用户更加方便的访问互联网，而不用记住很多很长的 ip 地址
    ICMP: 是一种基于无连接的网络层报文，internet 控制报文协议，作用回传网络是否通畅，主机是否可达，路由是否可用等报文信息IP 数据报分片的重组通常发生在 ()
    ```

- IP 数据报分片的重组通常发生在 ()

    - ```
        源主机和数据报经过的路由器上
        ```

    - ```
        源主机上
        ```

    - ```
        数据报经过的路由器上
        ```

    - ```
        目的主机上
        ```

```
  1.IP 数据报分片的原因：
  在 TCP/IP 分层中，数据链路层用 MTU (Maximum Transmission Unit，最大传输单元) 来限制所能传输的数据包大小，MTU 是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头，如以太网的 MTU 为 1500 字节，实际上数据帧的最大长度为 1512 字节，其中以太网数据帧的帧头为 12 字节。
  2. 分片的思想：
  当发送的 IP 数据报的大小超过了 MTU 时，IP 层就需要对数据进行分片，否则数据将无法发送成功。
  IP 分片发生在 IP 层 ，不仅 源端主机 会进行分片，中间的 路由器 也有可能分片，因为不同的网络的 MTU 是不一样的，如果传输路径上的某个网络的 MTU 比源端网络的 MTU 要小，路由器就可能对 IP 数据报再次进行分片。而分片数据的 重组 只会发生在 目的 端 的 IP 层。
```

- ip 地址 10.1.8.0/24 和 10.1.9.0/24，下列哪个是正确的汇总网段：(C)

    - ```
        10.0.0.0/8
        ```

    - ```
        10.1.0.0/16
        ```

    - ```
        10.1.8.0/23
        ```

    - ```
        10.1.10.0/24
        ```

    ```
    汇总网段的计算方法：
    1. 确定需要汇总的网段的子网地址。
    2. 将各网段的子网地址以二进制写出。 
    3. 比较各网段二进制表示的网络地址，从第 1 位比特开始进行比较记录连续的相同的比特， 从 不相同的比特位到第 32 个比特为填充 0。由此得到的地址为汇总后网段的 IP 地址，其网络位 为连续的相同的比特的位数。
    
    IP 路由汇总的优点有：
    1. 减小路由表的规模
    2. 减轻路由器 的负担 
    3. 减少数据包寻址时间
    
    在本题中，两个 IP 地址的不同比特位出现在第 24 位，所以 24-32 位填充 0，网络号为前 23 位，子网掩码为 255.255.254.0，
    即 10.1.8.0/23
    ```

- 属于网络 112.10.200.0/21 的地址是 ()

    - ```
        112.10.206.0
        ```

    - ```
        112.10.217.0
        ```

    - ```
        112.10.224.0
        ```

    - ```
        112.10.198.0
        ```

    ```
    112.10.200.0/21 的 21 代表 32 位 ip 地址中前 21 位是网络地址， 这是子网掩码的另外一种表示形式。因为 ip 地址是以点分十进制表示的， 前两个占了 2x8=16 位，还有 5 位用第三个位置的 200 的前五位二进制凑齐。 200 的二进制形式：11001 000， 而剩余的三位和最后一个点分十进制的 0， 二进制形式为 0000 0000， 共 11 位为主机地址， 主机地址从 000 0000 0000 ~ 111 1111 1111， 结合前边的网络地址，最终结果为地址从 112.10.200.0 ~ 112.10.207.255 为有效地址。
    
    
    ```

- 下列 TCP 连接建立过程描述正确的是：C

    - ```
        服务端收到客户端的SYN包后等待2*ml时间后就会进入SYN_SENT状态
        ```

    - ```
        服务端收到客户端的ACK包后会进入SYN_RCVD状态
        ```

    - ```
        当客户端处于ESTABLISHED状态时，服务端可能仍然处于SYN_RCVD状态
        ```

    - ```
        服务端未收到客户端确认包，等待2*ml时间后会直接关闭连接
        ```

![三次握手](待解决问题\三次握手.png)

![四次挥手](待解决问题\四次挥手.png)

```
A：SYN_SENT 是客户端发送 SYN 包之后的立即进入的状态，不用等待 2ml
B：服务端收到客户端的 SYN 包后会进入 SYN_RCVD 状态，服务端收到 ACK 包后会进入 established 状态。
C： 当客户端处于 ESTABLISHED 状态时，服务端等待接收客户端的 ACK，所以可能处于 SYN_RCVD 状态。
D： 客户端收到服务端确认包后，等待 2*ml 时间后会直接关闭连接。若没有收到，则不会关闭连接。
```

- TCP 建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为 1000，确认序列号为 2000，请问第二次握手报文的发送序列号和确认序列号分别为

    - ```
        1999，999
        ```

    - ```
        1999，1000
        ```

    - ```
        999，2000
        ```

    - ```
        999，1999
        ```

    ```
    简化一下，其实有两个序列，客户端发送 X，服务器发送 Y。三次握手分别是
    
    客户端：发送 X
    服务端：发送 Y， 确认 X+1 
    客户端：发送 X+1（1000），确认 Y+1（2000）
    
    第二次的确认是第三次的发送
    可以反推第二次为 1999, 确认 1000
    
    这不是同一端的数据包。
    ```

- 应用程序 PING 发出的是什么报文

    - ```
        ICMP 请求报文
        ```

    ```
    程序发送的是 ICMP 请求报文，路由发回 ICMP 应答报文，并被程序接收，因此程序接受的是 ICMP 应答报文
    ```

- 在因特网中，下列哪个不是 IP 层所需解决的问题(A)

    - ```
        流量控制
        ```

    - ```
        路径选择
        ```

    - ```
        寻址
        ```

    - ```
        分段和重新组装
        ```

    ```
    数据链路层层：差错控制
    网络层：网络互连、路由选择、拥塞控制，通过寻址建立节点间连接
    （网络层协议能补偿数据发送、传输以及接收的设备能力的不平衡性。分段和重组是指当数据从一个能处理较大数据单元的网络段传送到仅能处理较小数据单元的网络段时，网络层对数据包进行分段和重组，减小数据单元的大小）
    传输层：流量控制（流量控制由 TCP 负责）
    
    不同网络上的链路可以传输的最大报文大小是不同的，这就是我们通常所说的 MTU（最大传输单元）。为了使我们要传输的数据报能在不同网络中传输，当一些尺寸较大的数据报要在某个 MTU 值比较小的网络链路上传输时就可能需要对原来的数据报进行拆分，形成一个个小的分段，然后再把这些分段依次传输出去。这就是 IP 协议的分段功能。既然在发送节点对原来的数据报进行了拆分，在接收节点自然就面临了一个如何把这些被拆分的分段重新组合起来，还原成原来的大的数据报的问题，这就是 IP 协议的分段重组功能
    
    重新组装由目的端的 IP 层来完成，其目的是使分片和重新组装过程对运输层 (TCP 和 UDP) 是透明的，除了某些可能的越级操作外。
    ```

- 一台刚刚接入互联网的 WEB 服务器第一次被访问到时，不同协议的发生顺序是下面中的（ARP -> DNS -> HTTP）

    ```
    1、当给 WEB 服务器接上网线的时候，它会自动发送一条 ARP 信息，使得接入网关能找的到它； 
    网关上会形成一条类似：2c 96 1e 3c 3e 9b - 192.168.1.123 的 MAC 地址到 IP 地址的映射记录。 
    
    2、当第一个用户使用域名访问 WEB 服务器的时候，首先要进行一次 DNS 查询
    
    3、最后才是 http 协议
    ```

- 一台主机要实现通过局域网与另一个局域网通信，需要做的工作是？（定义一条本机指向所在网络网关的路由）

    ```
    本机只需设置本地网络默认网关，至于到目的网络，是网关路由器的工作
    ```

- 下列关于地址转换的描述，错误的是（B）

    - ```
        地址转换解决了因特网地址短缺所面临问题
        ```

    - ```
        地址转换实现了对用户透明的网络外部地址的分配
        ```

    - ```
        使用地址转换后，对"IP包加长"，"快速转发"不会造成什么影响
        ```

    - ```
        地址转换内部主机提供一定的”隐私”
        ```

- *HTTPS 采用* SSL 协议*实现安全网站访问*的

- 某公司申请到一个 C 类 IP 地址，但要连接 6 个的子公司，最大的一个子公司有 26 台计算机，每个子公司在一个网段中，则子网掩码应设为（D）

    - ```
        255.255.255.192
        ```

    - ```
        255.255.255.128
        ```

    - ```
        255.255.255.0
        ```

    - ```
        255.255.255.224
        ```

    ```
    一个子公司 26 台机器，2^5 = 32，刚好够用，所以 IP 地址最后 8 位里的后 5 位用作子网内区分的地址。
    前 3 位就是子网掩码了，即 11100000，即 224。
    选 D，255.255.255.224
    ```

- 网络地址 172.16.22.38/28 请写出此地址的子网 ID 以及广播地址，此地址所处子网可用主机数

    ```
    172.16.22.38/28
    
    此 IP 地址 28 表示 子网掩码的前 28 位作为网络号，是 1， 即 
    1111	1111	1111	1111	1111	1111	1111	0000
    所以可以计算该 IP 的网络号为: 
    
    38---> 0010 0110
    &      1111 0000
    ---------------------------
     32--> 0010 0000
    所以可得到子网 ID 是 172.16.22.32
    
    32(网络地址共32位) - 28 = 4 , 由此可计算该子网最多有  2^4 = 16 台主机，去掉网络号和广播地址是 16 - 2 = 14
    
    主机号全部为 0 的主机作为网络号， 主机号全部为 1 的作为广播地址，
    所以，可得该 IP 的广播地址是:   0010 1111-->47
    所以广播地址是 172.16.22.47
    发表于 2016-03-04 17:01:34
    ```

- TCP 的三次握手过程中，accept 发生在三次握手的哪个阶段？

    - ```
        三次握手之后
        ```

- 私有IP地址范围：

    ```
    A: 10.0.0.0~10.255.255.255 即10.0.0.0/8
    B:172.16.0.0~172.31.255.255即172.16.0.0/12
    C:192.168.0.0~192.168.255.255 即192.168.0.0/16
    ```

- ```java
    int   listen(int   sockfd,   int   backlog) 
    ```

    ```
    backlog是未经过处理的连接请求队列可以容纳的最大数目。即每一个连入请求都要进入一个连入请求队列，等待 listen的程序调用 accept () 函数来接受这个连接。当系统还没有调用accept() 函数的时候，如果有很多连接，那么本地能够等待的最大数目就是 backlog的数值。  
    ```

##### 0721

- 求和（dfs）

##### 0723

- 在使用 limit 子句时，如果没有足够的行，则：
    - SELECT * FROM table LIMIT 4（从第一行开始向下依次选四行数据） 
    - SELECT * FROM table LIMIT 4 OFFSET 2  （跳过前两行，从第三行开始向下依次选四行数据）  
    - SELECT * FROM table LIMIT -1 OFFSET 3 （跳过前三行，列出表中其余行的数据
    - limit 用来选择返回的行数，有两个参数，偏移量及行数，若只有一个参数默认为行数，若行数设为 - 1 则是从偏移量到最后，若行数不够则返回能够有的行数

##### 0724（）

##### 0725

- 与 Mysql 服务器相互作用的通讯协议包括 TCP／IP、Socket、共享内存、命名管道；（不含UDP）

##### 0727

- 嵌套查询的子查询列名顺序和 in 之前的返回列名一致
- 动态规划（合唱团）

##### 0728

- 如下 SQL 语句中，____可能返回 null 值。

    ```sql
    (1) select count(*) from t1;
    (2) select max(col1) from t1;
    (3) select concat('max=',max(col1)) from t1;
    ```

    ```sql
    (1). 若表 t1 中有记录，会返回记录数；若无记录，则返回 0；
    (2). 若表 t1 中存在列 col 为 null, 则结果返回 null; 
    MySQL concat 函数使用方法：CONCAT(str1,str2,…)返回结果为连接参数产生的字符串。如有任何一个参数为 NULL ，则返回值为 NULL。
    ```

- 从表 TABLE_NAME 中提取前 10 条记录

    - **Sql server:**select TOP N * from table_name. 
    - **MySQL:** select * from table_name limit 0,10; 
    - **Oracle:**select * from table_name where rownum＜=10  

- SQL 中的通配符不包含 *。

    ```
    _    与任意单字符匹配
    %    与包含一个或多个字符的字符串匹配
    []  与特定范围（例如，[a-f]）或特定集（例如，[abcdef]）中的任意单字符匹配。
    [^]  与特定范围（例如，[^a-f]）或特定集（例如，[^abcdef]）之外的任意单字符匹配。
    例子:
    ・WHERE FirstName LIKE '_im' 可以找到所有三个字母的、以 im 结尾的名字（例如，Jim、Tim）。 
    ・WHERE LastName LIKE '% stein' 可以找到姓以 stein 结尾的所有员工。 
    ・WHERE LastName LIKE '% stein%' 可以找到姓中任意位置包括 stein 的所有员工。 
    ・WHERE FirstName LIKE '[JT] im' 可以找到三个字母的、以 im 结尾并以 J 或 T 开始的名字（即仅有 Jim 和 Tim） 
    ・WHERE LastName LIKE 'm [^c]%' 可以找到以 m 开始的、后面的（第二个）字母不为 c 的所有姓。
    ```

-  RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS   SQL Server, IBM DB2, Oracle, MySQL 以及 Microsoft Access。hadoop 是分布式数据库 ,hadoop 是分布式文件系统，不是关系型数据库管理系统。